/* 
  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
  
  Licensed under the Apache License, Version 2.0 (the "License").
  You may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  
      http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
import * as cdk from 'aws-cdk-lib';
import * as cr from 'aws-cdk-lib/custom-resources';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as nag from 'cdk-nag';
import * as path from 'path';
import * as s3 from 'aws-cdk-lib/aws-s3';
import * as secrets from 'aws-cdk-lib/aws-secretsmanager';

import {
    AGSLambdaFunction,
    AGSRestApi,
    AGSService,
    AGSSharedInfraClient,
    SubnetGroup,
} from '@ags-cdk/ags-service-template';
import { Construct, IConstruct } from 'constructs';

import { v4 as uuid } from 'uuid';

export interface S3EvidenceCollectorProps {
    evidenceStoreApi: AGSRestApi;
    attachmentBucket: s3.IBucket;
    sourceBuckets?: { bucketArn: string; account: string }[];
    service: AGSService;
    removalPolicy: cdk.RemovalPolicy;
}

export class S3EvidenceCollector extends Construct {
    constructor(scope: Construct, id: string, props: S3EvidenceCollectorProps) {
        super(scope, id);

        const apiSecret = new secrets.Secret(this, 'api-secret', {
            removalPolicy: props.removalPolicy,
        });

        suppressCdkNag(apiSecret, [
            {
                id: 'AwsSolutions-SMG4',
                reason: 'The API Key is generated by the evidence store APIs',
            },
        ]);

        new EvidenceProviderCreator(
            this,
            'creator',
            props.evidenceStoreApi.api.url,
            apiSecret,
            props.service.sharedInfraClient
        );

        const connectorLambda = new AGSLambdaFunction(this, 's3-evidence-collector', {
            description: 'Evidence Collector for S3',
            service: props.service,
            runtime: lambda.Runtime.NODEJS_18_X,
            handler: 'index.handler',
            code: lambda.Code.fromAsset(
                path.join(
                    __dirname,
                    '../../app/lambda/.aws-sam/build/s3-evidence-collector'
                )
            ),
            environment: {
                ATTACHMENT_BUCKET_NAME: props.attachmentBucket.bucketName,
                EVIDENCE_STORE_API: props.evidenceStoreApi.api.url,
                EVIDENCE_PROVIDER_ID: 's3-evidence-collector',
                SECRET_ID: apiSecret.secretName,
            },
            architecture: lambda.Architecture.ARM_64,
            timeout: cdk.Duration.minutes(5),
            tracing: lambda.Tracing.ACTIVE,
            initialPolicy: [
                new iam.PolicyStatement({
                    effect: iam.Effect.ALLOW,
                    actions: ['execute-api:Invoke'],
                    resources: [
                        props.evidenceStoreApi.api.arnForExecuteApi('POST', '/evidences'),
                    ],
                }),
            ],
        });

        suppressCdkNag(connectorLambda.lambdaFunction.role!, [
            {
                id: 'AwsSolutions-IAM4',
                reason: 'The privileges granted with the used managed policy meet the access required in this context.',
            },
            {
                id: 'AwsSolutions-IAM5',
                reason: 'The privileges granted with the used managed policy meet the access required in this context.',
            },
        ]);

        suppressDefaultPolicyCdkNag(connectorLambda.lambdaFunction.role!, [
            {
                id: 'AwsSolutions-IAM5',
                reason: 'The privileges granted with the used managed policy meet the access required in this context.',
            },
        ]);

        props.attachmentBucket.grantWrite(connectorLambda.lambdaFunction);
        props.attachmentBucket.encryptionKey?.grantEncryptDecrypt(
            connectorLambda.lambdaFunction
        );
        apiSecret.grantRead(connectorLambda.lambdaFunction);

        props.sourceBuckets?.forEach((x) => {
            // allow source bucket to invoke the lambda
            connectorLambda.lambdaFunction.addPermission(uuid(), {
                principal: new iam.ServicePrincipal('s3.amazonaws.com'),
                sourceAccount: x.account,
                action: 'lambda:InvokeFunction',
            });

            // allow lambda to read source bucket
            connectorLambda.lambdaFunction.addToRolePolicy(
                new iam.PolicyStatement({
                    actions: ['s3:GetObject*', 's3:GetBucket*', 's3:List*'],
                    effect: iam.Effect.ALLOW,
                    resources: [`${x.bucketArn}`, `${x.bucketArn}/*`],
                })
            );
        });

        new cdk.CfnOutput(this, 's3-collector-arn', {
            description: 'S3 Evidence Collector Lambda Function Arn',
            value: connectorLambda.lambdaFunction.functionArn,
        });

        new cdk.CfnOutput(this, 's3-collector-role-arn', {
            description: 'S3 Evidence Collector Lambda Function Role Arn',
            value: connectorLambda.lambdaFunction.role?.roleArn ?? '',
        });

        cdk.Aspects.of(this).add(new nag.AwsSolutionsChecks());
    }
}

class EvidenceProviderCreator extends Construct {
    constructor(
        scope: Construct,
        id: string,
        evidenceStoreUri: string,
        apiSecret: secrets.ISecret,
        sharedInfraClient: AGSSharedInfraClient
    ) {
        super(scope, id);

        const fn = new lambda.Function(this, 'handler', {
            runtime: lambda.Runtime.NODEJS_18_X,
            architecture: lambda.Architecture.ARM_64,
            handler: 'index.handler',
            code: lambda.AssetCode.fromAsset(
                path.join(__dirname, './evidence-provider-creator/dist')
            ),
            initialPolicy: [
                new iam.PolicyStatement({
                    actions: ['execute-api:Invoke'],
                    effect: iam.Effect.ALLOW,
                    resources: ['arn:aws:execute-api:*:*:*/*/*/*'],
                }),
            ],
            timeout: cdk.Duration.minutes(1),
            vpc: sharedInfraClient.vpc,
            vpcSubnets: sharedInfraClient.getSubnetsByGroupName(SubnetGroup.SERVICE),
        });

        suppressCdkNag(fn.role!, [
            {
                id: 'AwsSolutions-IAM4',
                reason: 'The privileges granted with the used managed policy meet the access required in this context.',
            },
        ]);

        suppressDefaultPolicyCdkNag(fn.role!, [
            {
                id: 'AwsSolutions-IAM5',
                reason: 'The privileges granted with the used managed policy meet the access required in this context.',
            },
        ]);

        apiSecret.grantWrite(fn);

        const provider = new cr.Provider(this, 'provider', {
            onEventHandler: fn,
        });

        new cdk.CustomResource(this, 'custom-resource', {
            serviceToken: provider.serviceToken,
            properties: {
                EvidenceStoreUri: evidenceStoreUri,
                ProviderId: 's3-evidence-collector',
                SchemaId: 's3-evidence-schema',
                SecretId: apiSecret.secretName,
            },
        });

        suppressCdkNagCustomCdkResource(provider, [
            {
                id: 'AwsSolutions-IAM4',
                reason: 'The privileges granted with the used managed policy meet the access required in this context.',
            },
            {
                id: 'AwsSolutions-IAM5',
                reason: 'The privileges granted with the used managed policy meet the access required in this context.',
            },
            {
                id: 'AwsSolutions-L1',
                reason: 'The lambda runtime is configured by CDK custom resource provider framework.',
            },
        ]);
    }
}

function suppressCdkNag(
    resource: IConstruct,
    rules: { id: string; reason: string }[]
): void {
    (resource.node.defaultChild as cdk.CfnResource).addMetadata('cdk_nag', {
        rules_to_suppress: rules,
    });
}

function suppressDefaultPolicyCdkNag(
    role: iam.IRole,
    rules: { id: string; reason: string }[]
): void {
    // find the default policy
    (
        role.node.findChild('DefaultPolicy').node.defaultChild as cdk.CfnResource
    ).addMetadata('cdk_nag', { rules_to_suppress: rules });
}

function suppressCdkNagCustomCdkResource(
    provider: cdk.custom_resources.Provider,
    rules: { id: string; reason: string }[]
): void {
    // find the role
    suppressCdkNag(
        provider.node.findChild('framework-onEvent').node.findChild('ServiceRole'),
        rules
    );
    suppressCdkNag(
        provider.node
            .findChild('framework-onEvent')
            .node.findChild('ServiceRole')
            .node.findChild('DefaultPolicy'),
        rules
    );

    const resource = provider.node
        .findChild('framework-onEvent')
        .node.findChild('Resource');

    (resource as cdk.CfnResource).addMetadata('cdk_nag', { rules_to_suppress: rules });
}
